# -*- coding: utf-8 -*-
"""unemployemnt by us quintile.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mknHFV7HnFea8ErGVHTL7t2GXuAvk-sX
"""

# Define the constants and initial state
L = [0.2, 0.2, 0.2, 0.2, 0.2]  # Quintile sizes
Y = 2000000  # Total income
C = 0.8  # Consumption fraction
I = 0.1  # Investment fraction
G = 400000  # Government spending
T = 0.2  # Tax rate
M = 0.2  # Marginal propensity to import
P = 1  # Price level
H = 100000  # Money supply
r = 0.05  # Interest rate
u = 0.035  # Overall unemployment rate
L_u = [0.04, 0.035, 0.03, 0.025, 0.02]  # Unemployment rate by quintile
W_min = 7.25  # Minimum wage

# Define the equations
def calc_N(L, u):
    return sum([L[i]*(1-u[i]) for i in range(5)])

def calc_Y(W_min, L):
    return sum([W_min*L[i] for i in range(5)])

def calc_C(Y, T, W_min, L, P):
    return C*(Y - T*Y - W_min*sum(L)*P)

def calc_I(Y, r):
    return I*Y - r

def calc_G(G):
    return G

def calc_T(Y, W_min, L, P):
    return T*Y + W_min*sum(L)*P

def calc_X(Y, M):
    return M*Y

def calc_P(Y, H):
    return H/Y

def calc_L(W_min, L, N):
    return [W_min*N/L[i] for i in range(5)]

# Define a function to calculate the new state of the model given a new minimum wage
def calc_new_state(W_new):
    # Calculate the new unemployment rates for each quintile to maintain an overall unemployment rate of 3.5%
    N = calc_N(L, L_u)
    L_new = calc_L(W_new, L, N)
    u_new = [u*(N/L[i]) for i in range(5)]

    # Calculate the new values of each variable using the updated minimum wage and unemployment rates
    Y_new = calc_Y(W_new, L_new)
    C_new = calc_C(Y_new, T, W_new, L_new, P)
    I_new = calc_I(Y_new, r)
    G_new = calc_G(G)
    T_new = calc_T(Y_new, W_new, L_new, P)
    X_new = calc_X(Y_new, M)
    P_new = calc_P(Y_new, H)

    # Return the new state of the model as a dictionary
    return {
        'W': W_new,
        'L': L_new,
        'u': u_new,
        'Y': Y_new,
        'C': C_new,
        'I': I_new,
        'G': G_new,
        'T': T_new,
        'X': X_new,
        'P': P_new
    }

# Example usage
new_state = calc_new_state(20.0)  # Calculate the new state of the model with a minimum wage of $8.00/hour
print(new_state['Y'])  # Print the new value of total income
print(new_state['C'])  # Print the new value of consumption
print(new_state['u'])

import numpy as np
import matplotlib.pyplot as plt

# Parameters
t_max = 100 # maximum number of periods
alpha = 0.5 # consumption share
beta = 1.5 # labor share
delta = 0.1 # depreciation rate
gamma = 2 # elasticity of substitution between consumption and leisure
w_min_0 = 10 # initial minimum wage
markup = 1.3 # markup over average cost
elasticity_ld = 0.5 # elasticity of labor demand
frictional_vacancies = 100 # number of frictional vacancies
structural_vacancies = 50 # number of structural vacancies
cost_of_entry = 100 # cost of entry
value_of_firm = 1000 # value of a firm
labor_supply = np.array([100, 200, 300, 400, 500]) # labor supply for each quintile
prev_salaries = np.array([8, 12, 18, 24, 30]) # previous salaries for each quintile
unemployment_rates = np.array([0.05, 0.04, 0.03, 0.02, 0.01]) # initial unemployment rates for each quintile

# Initialize variables
t = 0
w_min = w_min_0
e = np.zeros(5)
u = unemployment_rates * labor_supply
l = labor_supply
ld = np.zeros(5)
ur = np.zeros(5)
struct_unemp_rate = np.zeros(5)
rw = np.zeros(5)
prev_rw = np.zeros(5)
prev_salaries_wage_gap = np.zeros(5)

# Store variables over time
e_history = np.zeros((5, t_max))
u_history = np.zeros((5, t_max))
l_history = np.zeros((5, t_max))
consumption_history = np.zeros(t_max)
w_min_history = np.zeros(t_max)
unemployment_rates_history = np.zeros((5, t_max))
rw_history = np.zeros((5, t_max))
prev_salaries_wage_gap_history = np.zeros((5, t_max))

# Run simulation
while t < t_max:
    # Calculate labor demand
    vacancies = frictional_vacancies + structural_vacancies
    firm_entry_rate = 1 / (1 + cost_of_entry / value_of_firm)
    ld = vacancies + (1 - firm_entry_rate) * e

    # Calculate real wage for each quintile
    for i in range(5):
        ur[i] = frictional_vacancies / (frictional_vacancies + e[i])
        struct_unemp_rate[i] = structural_vacancies / e[i]
        w = w_min * markup * (ld[i] / e[i])**(-elasticity_ld)
        rw[i] = w / markup
        prev_salaries_wage_gap[i] = prev_salaries[i] - rw[i]

    # Calculate consumption and leisure
    consumption = alpha * np.sum(rw * e) + alpha * np.sum(prev_salaries_wage_gap * (prev_salaries_wage_gap > 0))
    leisure = (1 - alpha) * np.sum(l) ** (1 + gamma) / (1 + gamma)

    # Calculate new employment and unemployment levels
    new_e = ld**beta * (np.exp((prev_salaries_wage_gap - prev_rw) / rw) - 1)
    new_e[new_e < 0] = 0
    new_u = l - new_e

    # Update variables